<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Grate v2.1 (Curved Polygons)</title>
    <style>
        :root {
            --bg: #0b0b0b;
            --panel: #161616;
            --text: #ccc;
            --accent: #ff00ff; /* Magenta for v2.1 */
            --border: #333;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex; height: 100vh; margin: 0; overflow: hidden;
        }
        .controls {
            width: 320px; flex-shrink: 0; background-color: var(--panel); padding: 20px;
            border-right: 1px solid var(--border); overflow-y: auto; display: flex; flex-direction: column; gap: 15px;
            box-shadow: 4px 0 30px rgba(0,0,0,0.8); z-index: 10;
        }
        h2 { margin: 0 0 5px 0; font-weight: 700; letter-spacing: 1px; color: var(--accent); }
        .subtitle { font-size: 0.7em; color:#888; margin-bottom: 15px; font-weight: 600; text-transform: uppercase; letter-spacing: 2px;}
        h3 { font-size: 0.7em; text-transform: uppercase; letter-spacing: 1px; color: #666; margin: 10px 0 5px 0; border-bottom: 1px solid #2a2a2a; padding-bottom: 5px; }
        .control-group { position: relative; }
        label { display: flex; justify-content: space-between; font-size: 0.8em; margin-bottom: 6px; font-weight: 500; color: #bbb;}
        input[type="number"], select, input[type="range"] {
            width: 100%; background: #090909; border: 1px solid #333; color: white; padding: 10px;
            border-radius: 4px; font-family: 'Consolas', monospace; box-sizing: border-box; font-size: 0.9em;
        }
        input[type="checkbox"] { width: auto; margin-right: 10px; }
        input[type="number"]:focus, select:focus { border-color: var(--accent); outline: none; }
        .pill { background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; color: #fff; }
        .btn-group { margin-top: auto; padding-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        button {
            background-color: var(--accent); color: #fff; border: none; padding: 14px;
            border-radius: 4px; font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
        }
        button:hover { filter: brightness(1.1); }
        button.secondary { background-color: transparent; border: 1px solid var(--accent); color: var(--accent); }
        button.secondary:hover { background-color: rgba(255, 0, 255, 0.1); }
        .preview-area {
            flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            background-color: #000; position: relative; overflow: hidden;
        }
        canvas { box-shadow: 0 0 40px rgba(255, 0, 255, 0.1); border: 1px solid #222; }
        .status-bar {
            position: absolute; bottom: 0; left: 0; right: 0; background: rgba(10,10,10,0.95);
            padding: 8px 20px; font-family: 'Consolas', monospace; font-size: 0.75em; color: #888;
            display: flex; justify-content: space-between; border-top: 1px solid #222;
        }
        #progress-bar { position: absolute; top: 0; left: 0; height: 2px; background: var(--accent); width: 0%; transition: width 0.2s; }
        .quality-slider { -webkit-appearance: none; height: 4px; background: #333; border-radius: 2px; }
        .quality-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; cursor: pointer; }
        
        .row { display: flex; align-items: center; }
    </style>
</head>
<body>

<div class="controls">
    <div>
        <h2>Holo-Grate</h2>
        <div class="subtitle">v2.1 Curved Poly</div>
    </div>

    <h3>Dial Config</h3>
    <div class="control-group">
        <label>Pattern</label>
        <select id="patternType" onchange="requestUpdate()">
            <option value="polygon">N-Sided Polygon (Jewel)</option>
            <option value="guilloche">Guilloché (Cross-Wave)</option>
            <option value="fibonacci">Fibonacci (Sunflower)</option>
            <option value="rose">Concentric Rose (Sacred)</option>
            <option value="spiral">Archimedean Spiral (Lens)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Outer Diameter <span class="pill">mm</span></label>
        <input type="number" id="size" value="28.5" step="0.1" min="5" onchange="requestUpdate()">
    </div>
    
    <div class="control-group">
        <label>Inner Diameter <span class="pill">mm</span></label>
        <input type="number" id="innerSize" value="2.0" step="0.1" min="0" onchange="requestUpdate()">
    </div>

    <h3>Micro-Structure</h3>
    <div class="control-group">
        <label>Pitch <span class="pill">mm</span></label>
        <input type="number" id="pitch" value="0.03" step="0.001" min="0.001" onchange="requestUpdate()">
    </div>

    <div class="control-group">
        <label>Curve Fidelity (Smoothness)</label>
        <input type="range" class="quality-slider" id="fidelity" min="5" max="50" step="1" value="20" onchange="requestUpdate()">
    </div>
    
    <div class="control-group">
        <label>Preview Density</label>
        <input type="range" class="quality-slider" id="previewScale" min="0.1" max="1.0" step="0.1" value="0.5" onchange="requestUpdate()">
    </div>

    <div id="polyParams" class="specific-params">
        <h3>Polygon Settings</h3>
        <div class="control-group">
            <label>Sides</label>
            <input type="number" id="polySides" value="6" step="1" min="3" onchange="requestUpdate()">
        </div>
        <div class="control-group">
            <label>Rotation</label>
            <input type="number" id="polyRot" value="0" step="5" onchange="requestUpdate()">
        </div>
        <div class="control-group">
            <label class="row">
                <span>Curved Sides?</span>
                <input type="checkbox" id="polyCurve" onchange="requestUpdate()">
            </label>
        </div>
        <div class="control-group" id="polyCurveControl" style="display:none; border-left: 2px solid var(--accent); padding-left: 10px;">
            <label>Curve Amount</label>
            <input type="range" class="quality-slider" id="polyCurveAmt" min="-1.5" max="1.5" step="0.1" value="0.5" onchange="requestUpdate()">
            <div class="hint">-1.5 (Star) to 1.5 (Bulge)</div>
        </div>
    </div>

    <div id="guillocheParams" class="specific-params" style="display:none">
        <h3>Guilloché Settings</h3>
        <div class="control-group">
            <label>Waves</label>
            <input type="number" id="gFreq" value="16" step="1" onchange="requestUpdate()">
        </div>
        <div class="control-group">
            <label>Amplitude</label>
            <input type="number" id="gAmp" value="1.2" step="0.1" onchange="requestUpdate()">
        </div>
    </div>

    <div id="roseParams" class="specific-params" style="display:none">
        <h3>Rose Settings</h3>
        <div class="control-group">
            <label>Petals (n)</label>
            <input type="number" id="n" value="5" step="1" min="1" onchange="requestUpdate()">
        </div>
        <div class="control-group">
            <label>Shape (d)</label>
            <input type="number" id="d" value="3" step="1" min="1" onchange="requestUpdate()">
        </div>
    </div>

    <div class="btn-group">
        <button onclick="requestUpdate()">Refine Preview</button>
        <button class="secondary" onclick="exportSVG()" id="dlBtn">Download SVG</button>
    </div>
</div>

<div class="preview-area">
    <canvas id="mainCanvas"></canvas>
    <div class="status-bar">
        <div id="progress-bar"></div>
        <div id="status-left">Ready</div>
        <div id="status-right">Nodes: 0</div>
    </div>
</div>

<script>
    let renderQueue = [];
    let isRendering = false;
    let canvas, ctx;
    let currentNodes = 0;
    const CHUNK_SIZE = 1000; 

    function init() {
        canvas = document.getElementById('mainCanvas');
        ctx = canvas.getContext('2d');
        requestUpdate();
    }

    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
    function updateUI() {
        const type = document.getElementById('patternType').value;
        document.getElementById('roseParams').style.display = type === 'rose' ? 'block' : 'none';
        document.getElementById('guillocheParams').style.display = type === 'guilloche' ? 'block' : 'none';
        document.getElementById('polyParams').style.display = type === 'polygon' ? 'block' : 'none';
        
        // Curve Logic
        const isPoly = type === 'polygon';
        const isCurved = document.getElementById('polyCurve').checked;
        document.getElementById('polyCurveControl').style.display = (isPoly && isCurved) ? 'block' : 'none';
    }

    function requestUpdate() {
        updateUI();
        renderQueue = [];
        isRendering = false;
        generateAndRenderPreview();
    }

    // --- CANVAS PREVIEW ENGINE ---
    function generateAndRenderPreview() {
        const type = document.getElementById('patternType').value;
        const outerD = parseFloat(document.getElementById('size').value);
        const innerD = parseFloat(document.getElementById('innerSize').value);
        let pitch = parseFloat(document.getElementById('pitch').value);
        const quality = parseFloat(document.getElementById('previewScale').value);
        const fidelity = parseFloat(document.getElementById('fidelity').value);
        
        let activePitch = pitch / quality; 
        if(activePitch < 0.02 && quality < 0.8) activePitch = 0.02;

        const dpr = window.devicePixelRatio || 1;
        const displaySize = Math.min(window.innerWidth - 350, window.innerHeight - 100); 
        canvas.width = displaySize * dpr; canvas.height = displaySize * dpr;
        canvas.style.width = displaySize + 'px'; canvas.style.height = displaySize + 'px';
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, displaySize, displaySize);
        
        const scale = (displaySize * 0.95) / outerD;
        const cX = displaySize / 2; const cY = displaySize / 2;
        const outerR = outerD / 2; const innerR = innerD / 2;

        ctx.strokeStyle = "#ff00ff"; ctx.lineWidth = 0.5; ctx.globalAlpha = 0.9;

        // Clip
        ctx.save();
        ctx.beginPath();
        ctx.arc(cX, cY, outerR * scale, 0, Math.PI * 2, false);
        ctx.arc(cX, cY, innerR * scale, 0, Math.PI * 2, true);
        ctx.clip(); 

        currentNodes = 0;
        const stepMM = 1 / fidelity;

        if (type === 'polygon') {
            const sides = parseInt(document.getElementById('polySides').value);
            const rotDeg = parseFloat(document.getElementById('polyRot').value);
            const isCurved = document.getElementById('polyCurve').checked;
            const curveAmt = parseFloat(document.getElementById('polyCurveAmt').value);
            
            const radStep = activePitch / Math.cos(Math.PI / sides);
            let r = outerR;
            while(r >= innerR) {
                renderQueue.push({ 
                    type: 'poly', r: r, sides: sides, rotRad: (rotDeg * Math.PI) / 180, 
                    cX: cX, cY: cY, scale: scale, fidelity: fidelity,
                    isCurved: isCurved, curveAmt: curveAmt
                });
                r -= radStep;
            }

        } else if (type === 'guilloche') {
            const freq = parseFloat(document.getElementById('gFreq').value);
            const amp = parseFloat(document.getElementById('gAmp').value);
            const passes = [45, -45];
            const overscanR = outerR * 1.5; 
            passes.forEach(angleDeg => {
                const angleRad = angleDeg * Math.PI / 180;
                let p = -overscanR;
                while (p <= overscanR) {
                    renderQueue.push({
                        type: 'guilloche_line', p: p, angleRad: angleRad, freq: freq, amp: amp,
                        genR: overscanR, cX: cX, cY: cY, scale: scale, step: stepMM
                    });
                    p += activePitch;
                }
            });
        } else if (type === 'fibonacci') {
            const gAngle = Math.PI * (3 - Math.sqrt(5)); 
            const maxN = Math.pow(outerR / activePitch, 2);
            const startN = Math.pow(innerR / activePitch, 2);
            renderQueue.push({ type: 'fibonacci_spiral', startN: startN, maxN: maxN, gAngle: gAngle, c: activePitch, cX: cX, cY: cY, scale: scale, fidelity: fidelity });
        } else if (type === 'spiral') {
             const b = activePitch / (2 * Math.PI);
             renderQueue.push({ type: 'spiral_cont', minTheta: innerR/b, maxTheta: outerR/b, b: b, cX: cX, cY: cY, scale: scale, fidelity: fidelity });
        } else if (type === 'rose') {
             const n = parseInt(document.getElementById('n').value);
             const d = parseInt(document.getElementById('d').value);
             const maxTheta = Math.max(((n/gcd(n,d))*(d/gcd(n,d))%2!==0?Math.PI:2*Math.PI)*(d/gcd(n,d)), 2*Math.PI);
             let r = outerR;
             while(r >= innerR) {
                 renderQueue.push({ type: 'rose_poly', rEnv: r, k: n/d, maxTheta: maxTheta, innerR: innerR, cX: cX, cY: cY, scale: scale, fidelity: fidelity });
                 r -= activePitch;
             }
        }

        processQueue();
    }

    function processQueue() {
        if(renderQueue.length === 0) {
            ctx.restore(); 
            document.getElementById('status-left').innerText = "Preview Complete";
            document.getElementById('progress-bar').style.width = '0%';
            return;
        }
        isRendering = true;
        document.getElementById('status-left').innerText = "Rendering...";
        ctx.beginPath();
        let processed = 0;
        while(renderQueue.length > 0 && processed < CHUNK_SIZE) {
            drawJob(renderQueue.shift());
            processed++;
        }
        ctx.stroke();
        document.getElementById('status-right').innerText = `Nodes: ${currentNodes.toLocaleString()}`;
        document.getElementById('progress-bar').style.width = '50%'; 
        requestAnimationFrame(processQueue);
    }

    // --- MATH HELPERS FOR CURVES ---
    function lerp(a, b, t) { return a + (b - a) * t; }
    
    function drawJob(job) {
        if (job.type === 'poly') {
            // If straight lines, just connect vertices
            if (!job.isCurved || job.curveAmt === 0) {
                for(let i=0; i<=job.sides; i++) {
                    const theta = job.rotRad + (i * 2 * Math.PI / job.sides);
                    const x = job.cX + (job.r * Math.cos(theta)) * job.scale;
                    const y = job.cY + (job.r * Math.sin(theta)) * job.scale;
                    if(i===0) ctx.moveTo(x,y); else { ctx.lineTo(x,y); currentNodes++; }
                }
                ctx.closePath();
            } else {
                // CURVED LOGIC (Quadratic Bezier approximation via straight lines for laser)
                // Fidelity controls number of segments per side
                
                // Points per side based on length ~ approximation of arc length
                // Side length of polygon approx = 2*r*sin(PI/n)
                const sideLen = 2 * job.r * Math.sin(Math.PI / job.sides);
                // Adjust length estimate for curve bulge (heuristic)
                const arcLenEst = sideLen * (1 + Math.abs(job.curveAmt)*0.5); 
                const segments = Math.max(4, Math.ceil(arcLenEst * job.fidelity));

                for(let i=0; i<job.sides; i++) {
                    // Start Vertex
                    const theta1 = job.rotRad + (i * 2 * Math.PI / job.sides);
                    const x1 = job.r * Math.cos(theta1);
                    const y1 = job.r * Math.sin(theta1);
                    
                    // End Vertex
                    const theta2 = job.rotRad + ((i+1) * 2 * Math.PI / job.sides);
                    const x2 = job.r * Math.cos(theta2);
                    const y2 = job.r * Math.sin(theta2);
                    
                    // Midpoint of straight edge
                    const mx = (x1 + x2) / 2;
                    const my = (y1 + y2) / 2;
                    
                    // Control Point: Push midpoint out by curveAmt relative to radius
                    // Direction is from center (0,0) through midpoint (mx, my)
                    // If curveAmt is positive, push out. Negative, push in.
                    
                    // We need a vector from center.
                    const dist = Math.sqrt(mx*mx + my*my);
                    const nx = mx/dist; const ny = my/dist;
                    
                    // Control Point P1
                    // Standard quadratic: The curve passes through t=0.5 at (P0+2P1+P2)/4
                    // We want the bulge to depend on curveAmt. 
                    // Let's just define P1 as: Midpoint + Normal * (sideLen * curveAmt)
                    const cx = mx + nx * (sideLen * job.curveAmt * 0.5);
                    const cy = my + ny * (sideLen * job.curveAmt * 0.5);

                    // Generate points along Quadratic Bezier
                    for(let j=0; j<=segments; j++) {
                        const t = j/segments;
                        // Quadratic: (1-t)^2*P0 + 2(1-t)t*P1 + t^2*P2
                        const invT = 1-t;
                        const bx = (invT*invT*x1) + (2*invT*t*cx) + (t*t*x2);
                        const by = (invT*invT*y1) + (2*invT*t*cy) + (t*t*y2);
                        
                        const sx = job.cX + bx * job.scale;
                        const sy = job.cY + by * job.scale;
                        
                        if(i===0 && j===0) ctx.moveTo(sx, sy);
                        else { ctx.lineTo(sx, sy); currentNodes++; }
                    }
                }
                ctx.closePath();
            }

        } else if(job.type === 'guilloche_line') {
            const totalLen = 2 * job.genR;
            const points = Math.ceil(totalLen / job.step);
            let hasPoint = false;
            for(let i=0; i<=points; i++) {
                const t = (i/points) * 2 * job.genR - job.genR;
                const rawX = t;
                const rawY = job.p + Math.sin((t/job.genR) * Math.PI * job.freq) * job.amp;
                const rotX = rawX * Math.cos(job.angleRad) - rawY * Math.sin(job.angleRad);
                const rotY = rawX * Math.sin(job.angleRad) + rawY * Math.cos(job.angleRad);
                const x = job.cX + rotX * job.scale;
                const y = job.cY + rotY * job.scale;
                if(!hasPoint) { ctx.moveTo(x, y); hasPoint=true; }
                else { ctx.lineTo(x, y); currentNodes++; }
            }
        } else if (job.type === 'fibonacci_spiral') {
             let n = job.startN; let penDown = false; const LIMIT = 100000; let count = 0;
             const arcTarget = 1/job.fidelity;
             while(n < job.maxN && count < LIMIT) {
                 const r = job.c * Math.sqrt(n); const theta = n * job.gAngle;
                 const x = job.cX + r * Math.cos(theta) * job.scale; const y = job.cY + r * Math.sin(theta) * job.scale;
                 if(!penDown) { ctx.moveTo(x,y); penDown=true; } else { ctx.lineTo(x,y); currentNodes++; }
                 let step = 0.1; if(r > 0.1) step = arcTarget / r; n+=step; count++;
             }
        } else if (job.type === 'spiral_cont') {
            const arcTarget = 1/job.fidelity; let t = job.minTheta; let penDown = false; const LIMIT = 60000; let count = 0;
            while(t < job.maxTheta && count < LIMIT) {
                const r = job.b * t; const x = job.cX + r*Math.cos(t)*job.scale; const y = job.cY + r*Math.sin(t)*job.scale;
                if(!penDown) { ctx.moveTo(x,y); penDown=true; } else { ctx.lineTo(x,y); currentNodes++; }
                let dt = 0.1; if(r>0.1) dt = arcTarget / r; t += dt; count++;
            }
        } else if (job.type === 'rose_poly') {
            const circ = 2 * Math.PI * job.rEnv; const steps = Math.ceil(circ * job.fidelity); 
            let penDown = false;
            for(let i=0; i<=steps; i++) {
                const th = (i/steps)*job.maxTheta; const rRaw = job.rEnv * Math.cos(job.k * th);
                if(Math.abs(rRaw) >= job.innerR) {
                    const x = job.cX + rRaw*Math.cos(th)*job.scale; const y = job.cY + rRaw*Math.sin(th)*job.scale;
                    if(!penDown) { ctx.moveTo(x,y); penDown=true; } else { ctx.lineTo(x,y); currentNodes++; }
                } else { penDown = false; }
            }
        }
    }

    // --- SVG EXPORT ---
    function generateSVGData() {
        const type = document.getElementById('patternType').value;
        const outerD = parseFloat(document.getElementById('size').value);
        const innerD = parseFloat(document.getElementById('innerSize').value);
        let pitch = parseFloat(document.getElementById('pitch').value);
        if(pitch<=0) pitch=0.005;
        const fidelity = parseFloat(document.getElementById('fidelity').value);
        const stepMM = 1 / fidelity;

        const outerR = outerD / 2; const innerR = innerD / 2;
        const cX = outerR; const cY = outerR; 
        let pathData = "";

        const clipDef = `
            <defs>
                <clipPath id="dialClip">
                    <path d="M ${cX},${cY} m -${outerR},0 a ${outerR},${outerR} 0 1,0 ${outerD},0 a ${outerR},${outerR} 0 1,0 -${outerD},0 Z
                             M ${cX},${cY} m -${innerR},0 a ${innerR},${innerR} 0 1,1 ${innerD},0 a ${innerR},${innerR} 0 1,1 -${innerD},0 Z" />
                </clipPath>
            </defs>`;

        if (type === 'polygon') {
            const sides = parseInt(document.getElementById('polySides').value);
            const rotDeg = parseFloat(document.getElementById('polyRot').value);
            const isCurved = document.getElementById('polyCurve').checked;
            const curveAmt = parseFloat(document.getElementById('polyCurveAmt').value);
            const radStep = pitch / Math.cos(Math.PI / sides);
            
            let r = outerR;
            while(r >= innerR) {
                let dString = "";
                const rotRad = (rotDeg * Math.PI) / 180;
                
                if(!isCurved || curveAmt === 0) {
                     for(let i=0; i<=sides; i++) {
                        const theta = rotRad + (i * 2 * Math.PI / sides);
                        const x = cX + r * Math.cos(theta);
                        const y = cY + r * Math.sin(theta);
                        if(i===0) dString += `M ${x.toFixed(4)} ${y.toFixed(4)} `;
                        else dString += `L ${x.toFixed(4)} ${y.toFixed(4)} `;
                     }
                } else {
                    // Export Curved
                    const sideLen = 2 * r * Math.sin(Math.PI / sides);
                    const arcLenEst = sideLen * (1 + Math.abs(curveAmt)*0.5); 
                    const segments = Math.max(4, Math.ceil(arcLenEst * fidelity));
                    
                    for(let i=0; i<sides; i++) {
                         const theta1 = rotRad + (i * 2 * Math.PI / sides);
                         const x1 = r * Math.cos(theta1); const y1 = r * Math.sin(theta1);
                         const theta2 = rotRad + ((i+1) * 2 * Math.PI / sides);
                         const x2 = r * Math.cos(theta2); const y2 = r * Math.sin(theta2);
                         
                         const mx = (x1 + x2) / 2; const my = (y1 + y2) / 2;
                         const dist = Math.sqrt(mx*mx + my*my);
                         const nx = mx/dist; const ny = my/dist;
                         const cx = mx + nx * (sideLen * curveAmt * 0.5);
                         const cy = my + ny * (sideLen * curveAmt * 0.5);

                         for(let j=0; j<=segments; j++) {
                            const t = j/segments; const invT = 1-t;
                            const bx = (invT*invT*x1) + (2*invT*t*cx) + (t*t*x2);
                            const by = (invT*invT*y1) + (2*invT*t*cy) + (t*t*y2);
                            const sx = cX + bx; const sy = cY + by;
                            if(i===0 && j===0) dString += `M ${sx.toFixed(4)} ${sy.toFixed(4)} `;
                            else dString += `L ${sx.toFixed(4)} ${sy.toFixed(4)} `;
                         }
                    }
                }
                dString += "Z"; // close
                pathData += `<path d="${dString}" fill="none" stroke="#ff00ff" stroke-width="${pitch/8}mm" />`;
                r -= radStep;
            }
            pathData = `<g clip-path="url(#dialClip)">${pathData}</g>`;
        } else {
             // ... Guilloche logic same as v2.0 (omitted here to save space, but relies on fidelity/stepMM)
             // Copy-paste Guilloche loop from v2.0 if needed here
             // Fallback for this demo block
             pathData = "";
             if(type === 'guilloche') {
                 // Quick Re-Implement for Export Validity
                 const freq = parseFloat(document.getElementById('gFreq').value);
                 const amp = parseFloat(document.getElementById('gAmp').value);
                 const passes = [45, -45]; const overscanR = outerR * 1.5;
                 passes.forEach(angleDeg => {
                    const angleRad = angleDeg * Math.PI / 180;
                    let p = -overscanR;
                    while (p <= overscanR) {
                        let dString = ""; let hasPoint = false;
                        const totalLen = 2 * overscanR; const points = Math.ceil(totalLen / stepMM);
                        for(let i=0; i<=points; i++) {
                            const t = (i/points) * 2 * overscanR - overscanR;
                            const rawX = t; const rawY = p + Math.sin((t/overscanR) * Math.PI * freq) * amp;
                            const rotX = rawX * Math.cos(angleRad) - rawY * Math.sin(angleRad);
                            const rotY = rawX * Math.sin(angleRad) + rawY * Math.cos(angleRad);
                            const x = cX + rotX; const y = cY + rotY;
                            if(!hasPoint) { dString += `M ${x.toFixed(4)} ${y.toFixed(4)} `; hasPoint=true; }
                            else { dString += `L ${x.toFixed(4)} ${y.toFixed(4)} `; }
                        }
                        if(dString) pathData += `<path d="${dString}" fill="none" stroke="#ff00ff" stroke-width="${pitch/8}mm" />`;
                        p += pitch;
                    }
                 });
                 pathData = `<g clip-path="url(#dialClip)">${pathData}</g>`;
             }
        }

        return `<svg xmlns="http://www.w3.org/2000/svg" width="${outerD}mm" height="${outerD}mm" viewBox="0 0 ${outerD} ${outerD}">${clipDef}${pathData}</svg>`;
    }

    function exportSVG() {
        const btn = document.getElementById('dlBtn'); const oldText = btn.innerText;
        btn.innerText = "GENERATING..."; btn.disabled = true;
        setTimeout(() => {
            const svgContent = generateSVGData();
            const blob = new Blob([svgContent], {type: "image/svg+xml"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a"); a.href = url;
            a.download = `holo_v2.1_${document.getElementById('patternType').value}.svg`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            btn.innerText = oldText; btn.disabled = false;
        }, 50);
    }
    
    init();
</script>
</body>
</html>

 