<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo-Grate v5.0 (WYSIWYG)</title>
    <style>
        :root {
            --bg: #050505; --panel: #111; --text: #ddd;
            --accent: #ff00ff; /* Magenta */
            --border: #333; --danger: #ff1744; --success: #00e676;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); color: var(--text); display: flex; height: 100vh; margin: 0; overflow: hidden; }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: var(--bg); } ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        
        .controls { width: 340px; background: var(--panel); padding: 20px; border-right: 1px solid var(--border); overflow-y: auto; display: flex; flex-direction: column; gap: 15px; z-index: 10; box-shadow: 4px 0 30px rgba(0,0,0,0.5); }
        h2 { margin: 0 0 5px 0; color: var(--accent); letter-spacing: 1px; } .subtitle { font-size: 0.7em; color: #888; text-transform: uppercase; letter-spacing: 2px; }
        
        .control-group { position: relative; }
        label { display: flex; justify-content: space-between; font-size: 0.8em; margin-bottom: 6px; color: #bbb; }
        input, select { width: 100%; background: #080808; border: 1px solid #333; color: white; padding: 10px; border-radius: 4px; box-sizing: border-box; font-family: monospace; }
        input:focus { border-color: var(--accent); outline: none; }
        
        .dual-input { display: flex; gap: 10px; } .dual-input div { flex: 1; }
        .dual-label { font-size: 0.7em; color: #666; margin-bottom: 2px; }
        
        .btn-group { margin-top: auto; padding-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        button { background: var(--accent); color: #fff; border: none; padding: 12px; border-radius: 4px; font-weight: 700; cursor: pointer; text-transform: uppercase; }
        button:hover { filter: brightness(1.1); }
        button.secondary { background: transparent; border: 1px solid var(--accent); color: var(--accent); }
        
        .preset-container { background: #151515; padding: 10px; border: 1px solid #333; border-radius: 6px; margin-bottom: 10px; }
        .preset-row { display: flex; gap: 5px; margin-bottom: 5px; }
        
        .preview-area { flex-grow: 1; background: #000; position: relative; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        #bgGrid { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; 
            background-image: linear-gradient(#222 1px, transparent 1px), linear-gradient(90deg, #222 1px, transparent 1px); background-size: 50px 50px; opacity: 0.5; }
        canvas { box-shadow: 0 0 50px rgba(0,0,0,0.5); border: 1px solid #333; z-index: 5; }
        
        #exportOverlay { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.9); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #exportOverlay.active { opacity: 1; pointer-events: all; }
        .loader-bar { width: 300px; height: 4px; background: #333; margin-top: 10px; border-radius: 2px; overflow: hidden; }
        .loader-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s; }
        .loader-box { width: 300px; text-align: center; }

        .status-bar { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(20,20,20,0.9); padding: 5px 20px; font-size: 0.75em; color: #888; display: flex; justify-content: space-between; z-index: 20; border-top: 1px solid #333; }
        #progress-bar { position: absolute; top: 0; left: 0; height: 2px; background: var(--accent); width: 0%; transition: width 0.2s; }
        
        .opt-box { border: 1px solid #333; background: #1a1a1a; padding: 10px; border-radius: 4px; margin-top: 10px; }
    </style>
</head>
<body>

<div id="exportOverlay">
    <div class="loader-box">
        <h3 style="color:white; margin:0;">EXPORTING</h3>
        <div style="color:#888; font-size: 0.8em; margin-top:5px;" id="exportStatus">Initializing...</div>
        <div class="loader-bar"><div class="loader-fill" id="exportFill"></div></div>
    </div>
</div>

<div class="controls">
    <div><h2>Holo-Grate</h2><div class="subtitle">v5.0 WYSIWYG</div></div>

    <div class="preset-container">
        <label>PRESETS</label>
        <div class="preset-row">
            <select id="presetSelect" onchange="loadPreset()"><option value="">Load...</option></select>
            <button onclick="deletePreset()" style="width:40px; background:#333; color:#fff;">X</button>
        </div>
        <div class="preset-row">
            <input type="text" id="presetName" placeholder="Name...">
            <button onclick="savePreset()" id="btnSave">SAVE</button>
        </div>
    </div>

    <div class="control-group"><label>Pattern</label>
        <select id="patternType" onchange="requestUpdate()">
            <option value="polygon">N-Sided Polygon (Jewel)</option>
            <option value="guilloche">Guilloché (Sine Wave)</option>
            <option value="basket">Basket Weave (Triangle)</option>
            <option value="fibonacci">Fibonacci (Sunflower)</option>
            <option value="rose">Concentric Rose (Sacred)</option>
            <option value="spiral">Archimedean Spiral</option>
        </select>
    </div>

    <div class="control-group"><label>Outer Diameter (mm)</label><input type="number" id="size" value="28.5" step="0.1" oninput="requestUpdate()"></div>
    <div class="control-group"><label>Inner Diameter (mm)</label><input type="number" id="innerSize" value="2.0" step="0.1" oninput="requestUpdate()"></div>
    <div class="control-group"><label>Pitch (mm)</label><input type="number" id="pitch" value="0.03" step="0.001" oninput="requestUpdate()"></div>
    
    <div class="control-group"><label>Distress (0-0.5)</label><input type="range" id="distress" min="0" max="0.5" step="0.01" value="0" oninput="requestUpdate()"></div>
    <div class="control-group"><label>Smoothness</label><input type="range" id="fidelity" min="5" max="100" step="1" value="30" oninput="requestUpdate()"></div>
    <div class="control-group"><label>Preview Density</label><input type="range" id="previewScale" min="0.1" max="1.0" step="0.1" value="0.5" oninput="requestUpdate()"></div>
    
    <div class="control-group opt-box">
        <label style="color:var(--accent)">File Optimizer (mm)</label>
        <div class="dual-input">
            <div style="flex:2"><input type="number" id="minDist" value="0.01" step="0.001"></div>
            <div style="flex:1; align-self:center; font-size:0.7em; color:#888;">Min Dist</div>
        </div>
        <div style="font-size:0.7em; color:#666; margin-top:4px;">Set 0.01 to reduce file size safely.</div>
    </div>

    <div id="guillocheParams" class="specific-params" style="display:none">
        <label style="color:var(--accent)">Guilloché Modulation</label>
        <div class="control-group"><label>Frequency</label><div class="dual-input"><div><span class="dual-label">Inner</span><input type="number" id="gFreqStart" value="16" oninput="requestUpdate()"></div><div><span class="dual-label">Outer</span><input type="number" id="gFreqEnd" value="16" oninput="requestUpdate()"></div></div></div>
        <div class="control-group"><label>Amplitude</label><div class="dual-input"><div><span class="dual-label">Inner</span><input type="number" id="gAmpStart" value="0.5" step="0.1" oninput="requestUpdate()"></div><div><span class="dual-label">Outer</span><input type="number" id="gAmpEnd" value="1.5" step="0.1" oninput="requestUpdate()"></div></div></div>
        <div class="control-group"><label>Phase Offset (Deg)</label><input type="number" id="gPhase" value="0" step="15" oninput="requestUpdate()"></div>
    </div>

    <div id="basketParams" class="specific-params" style="display:none">
        <label style="color:var(--accent)">Basket Modulation</label>
        <div class="control-group"><label>Frequency</label><div class="dual-input"><div><span class="dual-label">Inner</span><input type="number" id="bFreqStart" value="20" oninput="requestUpdate()"></div><div><span class="dual-label">Outer</span><input type="number" id="bFreqEnd" value="20" oninput="requestUpdate()"></div></div></div>
        <div class="control-group"><label>Amplitude</label><div class="dual-input"><div><span class="dual-label">Inner</span><input type="number" id="bAmpStart" value="1.0" step="0.1" oninput="requestUpdate()"></div><div><span class="dual-label">Outer</span><input type="number" id="bAmpEnd" value="1.0" step="0.1" oninput="requestUpdate()"></div></div></div>
        <div class="control-group"><label>Phase Offset (Deg)</label><input type="number" id="bPhase" value="0" step="15" oninput="requestUpdate()"></div>
    </div>

    <div id="polyParams" class="specific-params">
        <label style="color:var(--accent)">Polygon Settings</label>
        <div class="control-group"><label>Sides (Min 3)</label><input type="number" id="polySides" value="6" min="3" oninput="requestUpdate()"></div>
        <div class="control-group"><label>Rotation Twist</label><div class="dual-input"><div><span class="dual-label">Start</span><input type="number" id="polyRotStart" value="0" step="5" oninput="requestUpdate()"></div><div><span class="dual-label">End</span><input type="number" id="polyRotEnd" value="90" step="5" oninput="requestUpdate()"></div></div></div>
        <div class="control-group"><label><input type="checkbox" id="polyCurve" onchange="requestUpdate()" style="width:auto"> Curved Sides?</label></div>
        <div id="polyCurveControl" class="control-group" style="display:none"><label>Curve Morph</label><div class="dual-input"><div><span class="dual-label">Start</span><input type="number" id="polyCurveStart" value="0.5" step="0.1" oninput="requestUpdate()"></div><div><span class="dual-label">End</span><input type="number" id="polyCurveEnd" value="0.5" step="0.1" oninput="requestUpdate()"></div></div></div>
    </div>

    <div id="roseParams" class="specific-params" style="display:none">
        <label style="color:var(--accent)">Rose Settings</label>
        <div class="control-group"><label>Petals (n)</label><input type="number" id="n" value="5" step="1" oninput="requestUpdate()"></div>
        <div class="control-group"><label>Shape (d)</label><input type="number" id="d" value="3" step="1" oninput="requestUpdate()"></div>
    </div>

    <div class="btn-group">
        <button onclick="forceReRender()">Refresh Preview</button>
        <button class="secondary" onclick="exportSVG()" id="dlBtn">Download SVG</button>
    </div>
</div>

<div class="preview-area">
    <div id="bgGrid"></div>
    <canvas id="mainCanvas"></canvas>
    <div class="status-bar">
        <div id="progress-bar"></div>
        <div id="status-left">Ready</div>
        <div id="status-right">Nodes: 0</div>
    </div>
</div>

<script>
    // PRESETS
    const STORAGE_KEY="holoGrate_v5.0_presets", CURR_KEY="holoGrate_v5.0_curr";
    const IDS = ["patternType","size","innerSize","pitch","distress","fidelity","minDist","polySides","polyRotStart","polyRotEnd","polyCurve","polyCurveStart","polyCurveEnd","bFreqStart","bFreqEnd","bAmpStart","bAmpEnd","bPhase","gFreqStart","gFreqEnd","gAmpStart","gAmpEnd","gPhase","n","d"];
    function initPresets(){
        const sel=document.getElementById("presetSelect"); const d=JSON.parse(localStorage.getItem(STORAGE_KEY)||"{}");
        sel.innerHTML='<option value="">Load...</option>';
        Object.keys(d).sort().forEach(k=>{let o=document.createElement("option");o.value=k;o.innerText=k;sel.appendChild(o)});
        const l=localStorage.getItem(CURR_KEY); if(l) applyState(JSON.parse(l));
    }
    function savePreset(){const n=document.getElementById("presetName").value.trim(); if(!n)return; const s={}; IDS.forEach(i=>{const e=document.getElementById(i);if(e)s[i]=e.type==="checkbox"?e.checked:e.value}); const d=JSON.parse(localStorage.getItem(STORAGE_KEY)||"{}"); d[n]=s; localStorage.setItem(STORAGE_KEY,JSON.stringify(d)); document.getElementById("btnSave").innerText="SAVED!"; setTimeout(()=>document.getElementById("btnSave").innerText="SAVE",1000); initPresets();}
    function loadPreset(){const n=document.getElementById("presetSelect").value; if(!n)return; const d=JSON.parse(localStorage.getItem(STORAGE_KEY)); if(d[n]) applyState(d[n]);}
    function deletePreset(){const n=document.getElementById("presetSelect").value; if(!n)return; if(confirm("Delete?")){const d=JSON.parse(localStorage.getItem(STORAGE_KEY)); delete d[n]; localStorage.setItem(STORAGE_KEY,JSON.stringify(d)); initPresets();}}
    function applyState(s){IDS.forEach(i=>{if(s[i]!==undefined){const e=document.getElementById(i);if(e)(e.type==="checkbox"?e.checked=s[i]:e.value=s[i])}}); requestUpdate();}
    function saveCurr(){const s={}; IDS.forEach(i=>{const e=document.getElementById(i);if(e)s[i]=e.type==="checkbox"?e.checked:e.value}); localStorage.setItem(CURR_KEY,JSON.stringify(s));}

    // CORE
    let q=[], canvas, ctx, nodes=0, resizeTimer;
    function init(){ initPresets(); canvas=document.getElementById("mainCanvas"); ctx=canvas.getContext("2d"); requestUpdate(); }
    function gcd(a,b){return b===0?a:gcd(b,a%b)}
    function lerp(a,b,t){return a+(b-a)*t}
    function getT(r,min,max){if(r<=min)return 0; if(r>=max)return 1; return (r-min)/(max-min);}
    
    function updateUI(){
        const t=document.getElementById("patternType").value;
        ["rose","guilloche","basket","poly"].forEach(k=>document.getElementById(k+"Params").style.display="none");
        if(t==="rose") document.getElementById("roseParams").style.display="block";
        if(t==="guilloche") document.getElementById("guillocheParams").style.display="block";
        if(t==="basket") document.getElementById("basketParams").style.display="block";
        if(t==="polygon") { document.getElementById("polyParams").style.display="block"; document.getElementById("polyCurveControl").style.display=document.getElementById("polyCurve").checked?"block":"none"; }
    }
    function forceReRender(){requestUpdate();}
    function requestUpdate(){
        updateUI(); saveCurr();
        const od=parseFloat(document.getElementById("size").value); const id=parseFloat(document.getElementById("innerSize").value);
        if(isNaN(od)||od<=0) return;
        q=[]; clearTimeout(resizeTimer); resizeTimer=setTimeout(()=>renderPreview(od,(id>=od?od-0.1:id)),10);
    }

    function getWaveY(job, t, p, rMod){
        const paramT = getT(rMod, job.rMin, job.rMax);
        const amp = lerp(job.aS, job.aE, paramT);
        const freq = lerp(job.fS, job.fE, paramT);
        const phaseOffset = (job.phaseDeg || 0) * Math.PI / 180;
        const phase = ((t/job.genR) * Math.PI * freq) + phaseOffset;
        if(job.type==="basket_line") return p + ((2/Math.PI)*Math.asin(Math.sin(phase))*amp);
        return p + Math.sin(phase)*amp;
    }

    // --- PREVIEW ---
    function renderPreview(od, id){
        const type=document.getElementById("patternType").value;
        let pitch=parseFloat(document.getElementById("pitch").value)||0.03;
        const scaleQ=parseFloat(document.getElementById("previewScale").value);
        const fidelity=parseFloat(document.getElementById("fidelity").value);
        const distress=parseFloat(document.getElementById("distress").value);
        
        let activePitch=pitch/scaleQ; if(activePitch<0.02 && scaleQ<0.8) activePitch=0.02;
        const dpr=window.devicePixelRatio||1; const dispSize=Math.min(window.innerWidth-360, window.innerHeight-50);
        canvas.width=dispSize*dpr; canvas.height=dispSize*dpr; canvas.style.width=dispSize+"px"; canvas.style.height=dispSize+"px";
        ctx.scale(dpr,dpr); ctx.clearRect(0,0,dispSize,dispSize);
        const pxPerMM=(dispSize*0.95)/od; const gridSize=10*pxPerMM; document.getElementById("bgGrid").style.backgroundSize=`${gridSize}px ${gridSize}px`;
        const cx=dispSize/2; const cy=dispSize/2; const or=od/2; const ir=id/2;
        
        ctx.strokeStyle= (type==="fibonacci") ? "#d500f9" : "#ff00ff"; 
        ctx.lineWidth=0.5; ctx.globalAlpha=0.8;
        ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, or*pxPerMM, 0, Math.PI*2, false); if(ir>0) ctx.arc(cx, cy, ir*pxPerMM, 0, Math.PI*2, true); ctx.clip();
        nodes=0; const stepMM=1/fidelity;

        // Populate Queue
        if(type==="guilloche"||type==="basket"){
            const isB=type==="basket"; const prefix=isB?"b":"g";
            const fS=parseFloat(document.getElementById(prefix+"FreqStart").value); const fE=parseFloat(document.getElementById(prefix+"FreqEnd").value);
            const aS=parseFloat(document.getElementById(prefix+"AmpStart").value); const aE=parseFloat(document.getElementById(prefix+"AmpEnd").value);
            const phase=parseFloat(document.getElementById(prefix+"Phase").value);
            const passes=[45,-45]; const overscan=or*1.5;
            passes.forEach(deg=>{
                const rad=deg*Math.PI/180; let p=-overscan;
                while(p<=overscan){
                    q.push({type:isB?"basket_line":"guilloche_line", p:p, angle:rad, fS:fS, fE:fE, aS:aS, aE:aE, phaseDeg:phase, genR:overscan, cx:cx, cy:cy, scale:pxPerMM, step:stepMM, distress:distress, rMin:ir, rMax:or});
                    p+=activePitch;
                }
            });
        }
        else if(type==="rose"){
            const n=parseInt(document.getElementById("n").value); const d=parseInt(document.getElementById("d").value);
            const maxTheta = 2 * Math.PI * d;
            let r=or;
            while(r>=ir){
                q.push({type:"rose", cx:cx, cy:cy, scale:pxPerMM, rEnv:r, k:n/d, maxTheta:maxTheta, fidelity:fidelity, distress:distress, innerR:ir});
                r-=activePitch;
            }
        }
        else if(type==="fibonacci"){
            const maxN=Math.pow(or/activePitch,2); const startN=Math.pow(ir/activePitch,2);
            q.push({type:"fib", n:startN, maxN:maxN, c:activePitch, cx:cx, cy:cy, scale:pxPerMM, fidelity:fidelity, distress:distress});
        }
        else if(type==="spiral"){
            const b=activePitch/(2*Math.PI);
            q.push({type:"spiral", t:ir/b, maxT:or/b, b:b, cx:cx, cy:cy, scale:pxPerMM, fidelity:fidelity, distress:distress});
        }
        else if(type==="polygon"){
            const sides=Math.max(3, parseInt(document.getElementById("polySides").value));
            const rS=parseFloat(document.getElementById("polyRotStart").value); const rE=parseFloat(document.getElementById("polyRotEnd").value);
            const isC=document.getElementById("polyCurve").checked;
            const cS=parseFloat(document.getElementById("polyCurveStart").value); const cE=parseFloat(document.getElementById("polyCurveEnd").value);
            const radStep=activePitch/Math.cos(Math.PI/sides); let r=or;
            while(r>=ir){ 
                q.push({type:"poly", r:r, sides:sides, rS:rS, rE:rE, isC:isC, cS:cS, cE:cE, cx:cx, cy:cy, scale:pxPerMM, fidelity:fidelity, distress:distress, rMin:ir, rMax:or}); 
                r-=radStep; 
            }
        }
        processQ();
    }

    function processQ(){
        if(q.length===0){ ctx.restore(); document.getElementById("status-left").innerText="Ready"; return; }
        ctx.beginPath(); let ops=0; const LIMIT=2000;
        while(q.length>0 && ops<LIMIT){ const job=q[0]; const res=drawPreview(job); ops+=res.ops; if(res.done) q.shift(); }
        ctx.stroke(); document.getElementById("status-right").innerText=nodes.toLocaleString()+" nodes"; requestAnimationFrame(processQ);
    }

    function drawPreview(job){
        let ops=0;
        const isGap = () => (job.distress>0 && Math.random()<job.distress);

        if(job.type.includes("line")){
            const len=2*job.genR; const points=Math.ceil(len/job.step);
            for(let i=0; i<=points; i++){
                const t=(i/points)*2*job.genR-job.genR;
                const rMod=Math.sqrt(t*t + job.p*job.p);
                const rawY=getWaveY(job, t, job.p, rMod);
                const rx=t*Math.cos(job.angle)-rawY*Math.sin(job.angle);
                const ry=t*Math.sin(job.angle)+rawY*Math.cos(job.angle);
                const x=job.cx+rx*job.scale; const y=job.cy+ry*job.scale;
                if(i===0) ctx.moveTo(x,y); else { 
                    if(isGap()) ctx.moveTo(x,y); 
                    else { ctx.lineTo(x,y); nodes++; ops++; }
                }
            }
            return {done:true, ops:ops};
        }
        else if(job.type==="rose"){
            const len=job.maxTheta*job.rEnv; const steps=Math.ceil(len*job.fidelity);
            let penDown=false;
            for(let i=0; i<=steps; i++){
                const th=(i/steps)*job.maxTheta; const rRaw=job.rEnv*Math.cos(job.k*th);
                if(Math.abs(rRaw)<job.innerR){ penDown=false; continue; }
                const x=job.cx+rRaw*Math.cos(th)*job.scale; const y=job.cy+rRaw*Math.sin(th)*job.scale;
                if(!penDown || i===0){ ctx.moveTo(x,y); penDown=true; }
                else { if(isGap()){ ctx.moveTo(x,y); } else { ctx.lineTo(x,y); nodes++; ops++; } }
            }
            return {done:true, ops:ops};
        }
        else if(job.type==="fib"){
            while(job.n < job.maxN && ops<500){
                const r=job.c*Math.sqrt(job.n); const th=job.n*(Math.PI*(3-Math.sqrt(5)));
                const x=job.cx+r*Math.cos(th)*job.scale; const y=job.cy+r*Math.sin(th)*job.scale;
                if(isGap()) ctx.moveTo(x,y);
                else { if(!job.lastX) ctx.moveTo(x,y); else ctx.lineTo(x,y); nodes++; ops++; }
                job.lastX=x; job.n+=0.2; 
            }
            return {done:job.n>=job.maxN, ops:ops};
        }
        else if(job.type==="poly"){
            // FULL POLY PREVIEW MATH (Fixed from v4.0)
            const paramT = getT(job.r, job.rMin, job.rMax);
            const rot = lerp(job.rS, job.rE, paramT); const rad = rot*Math.PI/180;
            const curve = lerp(job.cS, job.cE, paramT);
            
            const sideLen = 2*job.r*Math.sin(Math.PI/job.sides);
            const steps = Math.max(2, Math.ceil(sideLen * (1+Math.abs(curve))*job.fidelity));
            
            for(let i=0; i<job.sides; i++){
                const t1 = rad + (i*2*Math.PI/job.sides); const x1=job.r*Math.cos(t1); const y1=job.r*Math.sin(t1);
                const t2 = rad + ((i+1)*2*Math.PI/job.sides); const x2=job.r*Math.cos(t2); const y2=job.r*Math.sin(t2);
                
                const mx=(x1+x2)/2; const my=(y1+y2)/2;
                const dist=Math.sqrt(mx*mx+my*my); const nx=mx/dist; const ny=my/dist;
                const cpx = mx + nx*(sideLen*curve*0.5); const cpy = my + ny*(sideLen*curve*0.5);
                
                for(let k=0; k<=steps; k++){
                    const t = k/steps; const inv = 1-t;
                    let fx, fy;
                    if(!job.isC || curve===0){ fx=x1+(x2-x1)*t; fy=y1+(y2-y1)*t; }
                    else { fx = (inv*inv*x1) + (2*inv*t*cpx) + (t*t*x2); fy = (inv*inv*y1) + (2*inv*t*cpy) + (t*t*y2); }
                    
                    const sx = job.cx+fx*job.scale; const sy = job.cy+fy*job.scale;
                    if(i===0 && k===0) ctx.moveTo(sx,sy);
                    else { if(isGap()) ctx.moveTo(sx,sy); else { ctx.lineTo(sx,sy); nodes++; ops++; } }
                }
            }
            ctx.closePath();
            return {done:true, ops:ops};
        }
        else if(job.type==="spiral"){
            while(job.t<job.maxT && ops<500){
                const r=job.b*job.t; const x=job.cx+r*Math.cos(job.t)*job.scale; const y=job.cy+r*Math.sin(job.t)*job.scale;
                if(isGap()) ctx.moveTo(x,y);
                else { if(!job.lastX) ctx.moveTo(x,y); else ctx.lineTo(x,y); nodes++; ops++; }
                job.lastX=x; job.t+=0.1; 
            }
            return {done:job.t>=job.maxT, ops:ops};
        }
        return {done:true, ops:0};
    }

    // --- EXPORT ---
    async function exportSVG(){
        const btn=document.getElementById("dlBtn"); const overlay=document.getElementById("exportOverlay"); const fill=document.getElementById("exportFill"); const status=document.getElementById("exportStatus");
        btn.disabled=true; overlay.classList.add("active");
        
        // Params
        const type=document.getElementById("patternType").value;
        const od=parseFloat(document.getElementById("size").value); const id=parseFloat(document.getElementById("innerSize").value);
        let pitch=parseFloat(document.getElementById("pitch").value)||0.005;
        const fidelity=parseFloat(document.getElementById("fidelity").value); const stepMM=1/fidelity;
        const distress=parseFloat(document.getElementById("distress").value);
        const isGap = () => (distress>0 && Math.random()<distress);
        
        // OPTIMIZATION
        let minD = parseFloat(document.getElementById("minDist").value) || 0;
        if(type==="fibonacci" && minD < 0.005) minD = 0.005;
        const MIN_DIST_SQ = minD * minD;
        
        const or=od/2; const ir=id/2; const cx=or; const cy=or;
        const YIELD_MS=12; let lastYield=performance.now();
        async function checkYield(){ if(performance.now()-lastYield>YIELD_MS){ await new Promise(r=>setTimeout(r,0)); lastYield=performance.now(); } }

        let blobs=[];
        blobs.push(new Blob([`<svg xmlns="http://www.w3.org/2000/svg" width="${od}mm" height="${od}mm" viewBox="0 0 ${od} ${od}"><defs><clipPath id="c"><path d="M ${cx},${cy} m -${or},0 a ${or},${or} 0 1,0 ${od},0 a ${or},${or} 0 1,0 -${od},0 Z M ${cx},${cy} m -${ir},0 a ${ir},${ir} 0 1,1 ${id},0 a ${ir},${ir} 0 1,1 -${id},0 Z" /></clipPath></defs><g clip-path="url(#c)" fill="none" stroke="black" stroke-width="${pitch/8}mm">`], {type:"text/plain"}));

        let buffer=""; let pendingMove=null; let exportNodes=0; let lastX=null, lastY=null;

        const pt = (x, y, force) => {
            if (force || isGap()) {
                const xs = x.toFixed(4); const ys = y.toFixed(4);
                pendingMove = {x:xs, y:ys}; lastX = x; lastY = y; 
                return;
            }
            if (MIN_DIST_SQ > 0 && lastX !== null) {
                const dx = x - lastX; const dy = y - lastY;
                if (dx*dx + dy*dy < MIN_DIST_SQ) return; 
            }
            const xs = x.toFixed(4); const ys = y.toFixed(4);
            if(pendingMove) { buffer += `M${pendingMove.x} ${pendingMove.y} `; pendingMove=null; }
            buffer += `L${xs} ${ys} `;
            lastX = x; lastY = y; exportNodes++;
            if(buffer.length > 5000000) { blobs.push(new Blob([`<path d="${buffer}" />`], {type:"text/plain"})); buffer = ""; pendingMove = {x:xs, y:ys}; }
        };

        try {
            if(type==="guilloche"||type==="basket"){
                const isB=type==="basket"; const prefix=isB?"b":"g";
                const fS=parseFloat(document.getElementById(prefix+"FreqStart").value); const fE=parseFloat(document.getElementById(prefix+"FreqEnd").value);
                const aS=parseFloat(document.getElementById(prefix+"AmpStart").value); const aE=parseFloat(document.getElementById(prefix+"AmpEnd").value);
                const phase=parseFloat(document.getElementById(prefix+"Phase").value);
                const passes=[45,-45]; const overscan=or*1.5;
                let totalSteps=passes.length*(2*overscan/pitch); let currStep=0;
                for(const deg of passes){
                    const rad=deg*Math.PI/180; let p=-overscan;
                    while(p<=overscan){
                        const len=2*overscan; const pts=Math.ceil(len/stepMM);
                        for(let i=0; i<=pts; i++){
                            const t=(i/pts)*2*overscan-overscan;
                            const rMod=Math.sqrt(t*t + p*p);
                            const jobMock={rMin:ir, rMax:or, fS:fS, fE:fE, aS:aS, aE:aE, phaseDeg:phase, genR:overscan, type:isB?"basket_line":"guilloche_line"};
                            const rawY=getWaveY(jobMock, t, p, rMod);
                            const rx=t*Math.cos(rad)-rawY*Math.sin(rad);
                            const ry=t*Math.sin(rad)+rawY*Math.cos(rad);
                            pt(cx+rx, cy+ry, i===0);
                        }
                        p+=pitch; currStep++;
                        if(currStep%20===0) { await checkYield(); fill.style.width=Math.min(100,(currStep/totalSteps)*100)+"%"; status.innerText=`Nodes: ${exportNodes.toLocaleString()}`; }
                    }
                }
            }
            else if(type==="rose"){
                const n=parseInt(document.getElementById("n").value); const d=parseInt(document.getElementById("d").value);
                const maxTheta=2*Math.PI*d;
                let r=or; let totalR=(or-ir)/pitch; let currR=0;
                while(r>=ir){
                    const len=maxTheta*r; const steps=Math.ceil(len*fidelity);
                    let penDown=false;
                    for(let i=0; i<=steps; i++){
                        const th=(i/steps)*maxTheta; const rRaw=r*Math.cos((n/d)*th);
                        if(Math.abs(rRaw)<ir){ penDown=false; continue; }
                        const x=cx+rRaw*Math.cos(th); const y=cy+rRaw*Math.sin(th);
                        pt(x,y, !penDown); penDown=true;
                        if(i%1000===0) await checkYield();
                    }
                    r-=pitch; currR++;
                    fill.style.width=Math.min(100,(currR/totalR)*100)+"%"; status.innerText=`Nodes: ${exportNodes.toLocaleString()}`;
                }
            }
            else if(type==="fibonacci"){
                const maxN=Math.pow(or/pitch,2); const startN=Math.pow(ir/pitch,2); const gAngle=Math.PI*(3-Math.sqrt(5));
                let n=startN; let isFirst=true;
                while(n<maxN){
                    const r=pitch*Math.sqrt(n); const th=n*gAngle;
                    const x=cx+r*Math.cos(th); const y=cy+r*Math.sin(th);
                    pt(x,y, isFirst); isFirst=false;
                    let rSafe=Math.max(r,0.05); n+=stepMM/rSafe;
                    if(exportNodes%5000===0){ await checkYield(); status.innerText=`Nodes: ${exportNodes.toLocaleString()}`; }
                }
            }
            else if(type==="spiral"){
                const b=pitch/(2*Math.PI); const maxT=or/b; let t=ir/b;
                let isFirst=true;
                while(t<maxT){
                    const r=b*t; const x=cx+r*Math.cos(t); const y=cy+r*Math.sin(t);
                    pt(x,y, isFirst); isFirst=false;
                    let rSafe=Math.max(r,0.05); t+=stepMM/rSafe;
                    if(exportNodes%5000===0){ await checkYield(); status.innerText=`Nodes: ${exportNodes.toLocaleString()}`; }
                }
            }
            else if(type==="polygon"){
                const sides = Math.max(3, parseInt(document.getElementById('polySides').value));
                const rS = parseFloat(document.getElementById('polyRotStart').value); const rE = parseFloat(document.getElementById('polyRotEnd').value);
                const isC = document.getElementById('polyCurve').checked;
                const cS = parseFloat(document.getElementById('polyCurveStart').value); const cE = parseFloat(document.getElementById('polyCurveEnd').value);
                const radStep = pitch / Math.cos(Math.PI/sides);
                let r = or;
                while(r >= ir){
                    const paramT = getT(r, ir, or);
                    const rot = lerp(rS, rE, paramT); const rad = rot*Math.PI/180;
                    const curve = lerp(cS, cE, paramT);
                    const sideLen = 2*r*Math.sin(Math.PI/sides); const arcLenEst = sideLen * (1 + (isC?Math.abs(curve):0)*0.5); 
                    const segments = Math.max(4, Math.ceil(arcLenEst * fidelity));
                    
                    for(let i=0; i<sides; i++){
                        const t1=rad+(i*2*Math.PI/sides); const x1=r*Math.cos(t1); const y1=r*Math.sin(t1);
                        const t2=rad+((i+1)*2*Math.PI/sides); const x2=r*Math.cos(t2); const y2=r*Math.sin(t2);
                        
                        if(!isC || curve===0){
                            for(let k=0; k<=segments; k++){
                                const t=k/segments; const px=cx+x1+(x2-x1)*t; const py=cy+y1+(y2-y1)*t;
                                pt(px, py, i===0&&k===0);
                            }
                        } else {
                            const mx=(x1+x2)/2; const my=(y1+y2)/2;
                            const dist=Math.sqrt(mx*mx+my*my); const nx=mx/dist; const ny=my/dist;
                            const cpx=mx+nx*(sideLen*curve*0.5); const cpy=my+ny*(sideLen*curve*0.5);
                            for(let j=0; j<=segments; j++){
                                const t=j/segments; const inv=1-t;
                                const bx=(inv*inv*x1)+(2*inv*t*cpx)+(t*t*x2); const by=(inv*inv*y1)+(2*inv*t*cpy)+(t*t*y2);
                                pt(cx+bx, cy+by, i===0&&j===0);
                            }
                        }
                    }
                    if(distress===0 && buffer.length>0) buffer += "Z ";
                    r-=radStep;
                    if(exportNodes%5000===0) await checkYield();
                }
            }
            
            if(buffer.length>0) blobs.push(new Blob([`<path d="${buffer}" />`], {type:"text/plain"}));
            blobs.push(new Blob(['</g></svg>'], {type:"text/plain"}));
            
            const finalBlob = new Blob(blobs, {type:"image/svg+xml"});
            const url = URL.createObjectURL(finalBlob);
            const a = document.createElement("a"); a.href = url;
            a.download = `holo_v5.0_${type}.svg`; document.body.appendChild(a); a.click(); document.body.removeChild(a);

        } catch(e) { alert("Export Error: "+e.message); } finally { btn.disabled=false; overlay.classList.remove("active"); }
    }
    
    init();
</script>
</body>
</html>

